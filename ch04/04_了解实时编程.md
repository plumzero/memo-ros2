
参考:
- [Understanding real-time programming](https://docs.ros.org/en/foxy/Tutorials/Demos/Real-Time-Programming.html)

实时计算是许多机器人系统的关键特性，尤其是在安全至关重要和任务关键型应用中，例如自动驾驶车辆、航天器和工业制造。在设计和开发 ROS2 原型时充分考虑了实时性能的限制。

[这个文档](实时系统概述.md)概述了实时计算的要求以及软件工程师的最佳实践。简而言之: 为了构建实时计算机系统，实时循环必须定期更新以满足截止时间要求(或者只能容忍这些截止时间存在很小的误差，即最大允许抖动）。为此，必须避免执行路径中的非确定性操作，例如: 缺页事件、动态内存分配/释放以及会无限期阻塞的同步原语。

### 运行测试

**运行前请确保至少有 8G 可用内存。内存锁定后，交换分区将无法工作。**

运行演示程序，并重定向输出:
```s
pendulum_demo > output.txt
```

即使重定向了 stdout，还是会在控制台看到一些输出:
```s
Couldn't set scheduling priority and policy: Operation not permitted
mlockall failed: Cannot allocate memory
Couldn't lock all cached virtual memory.
Pagefaults from reading pages not yet mapped into RAM will be recorded.
No results filename given, not writing results
```
演示程序初始化阶段结束后，它会尝试将所有缓存内存锁定到 RAM 中，并阻止后续的动态内存分配 mlockall。这是为了防止页面错误导致大量新内存加载到 RAM 中。

发生这种情况时，演示程序将照常继续运行。在演示程序生成的 output.txt 文件底部，可以看到执行过程中遇到的页面错误数量:
```s
rttest statistics:
  - Minor pagefaults: 20
  - Major pagefaults: 0
```

如果想消除这些页面错误(pagefaults)，可以调整内存锁定权限。具体就是向`/etc/security/limits/conf`中添加如下格式代码:
```s
<your username>    -   memlock   <limit in kB>
```
limit 为 -1 时表示无限制。如果选择此选项，则可能需要在编辑文件后进行`ulimit -l unlimited`操作。

保存文件后，注销并重新登录。然后重新运行 pendulum_demo 调用。再次执行后的输出文件中要么会显示 zero pagefaults(表示成功)，要么会显示捕获到 bad_alloc 异常的错误信息。如果出现这种情况，说明没有足够的可用内存来锁定分配给该进程的内存。这需要在计算机上安装更多内存才能看到 zero pagefaults。

### 二次测试

要查看更多输出，需要运行该 pendulum_logger 节点。
```s
pendulum_logger
```
执行后可以看到"Logger node initialized."输出信息。

在另一个终端再次调用 pendulum_demo，会看到 pendulum_logger 终端将不断刷新类似如下的输出:
```s
Commanded motor angle: 1.570796
Actual motor angle: 1.570129
Current latency: 146558 ns
Mean latency: 98815.815618 ns
Min latency: 35335 ns
Max latency: 214396 ns
Minor pagefaults during execution: 0
Major pagefaults during execution: 0
```
这些信息是演示程序在执行阶段的运行时性能统计信息。

接下来进行延迟分析。

执行完毕后 pendulum_demo，可以看到演示收集到的最终统计数据:
```s
rttest statistics:
  - Minor pagefaults: 0
  - Major pagefaults: 0
  Latency (time after deadline was missed):
    - Min: 3354 ns
    - Max: 2752187 ns
    - Mean: 19871.8 ns
    - Standard deviation: 1.35819e+08

PendulumMotor received 985 messages
PendulumController received 987 messages
```

延迟字段以纳秒为单位显示更新循环的最小、最大和平均延迟。此处，延迟指的是更新实际发生的时间(即从预期时间算起的时间)。

实时系统的要求取决于应用。假设在这个演示中，有一个 1kHz(1 毫秒)的更新循环，并且最大允许延迟为更新周期的 5%。在这个目标下，上面运行的平均延迟非常理想，但最大延迟却超过了更新循环周期。这可能遇到了非确定性调度器的问题。如果当前是在纯净的 Linux 系统上运行，并且没有安装 RT_PREEMPT 内核，那么可能无法达到设定的实时目标，因为 Linux 调度器不允许在用户级别任意抢占线程。

此演示程序会尝试设置调度器和线程优先级，使其适合实时性能。如果此操作失败，会看到错误消息:"Couldn't set scheduling priority and policy: Operation not permitted"。可以设置调度程序的权限，具体就是向`/etc/security/limits.conf`中添加如下代码:
```s
<your username>    -   rtprio   98
```
rtprio(实时优先级)字段的范围为 0-99。但是，请勿将上限设置为 99，否则您的进程可能会干扰以最高优先级运行的重要系统进程(例如看门狗进程)。本演示将尝试以优先级 98 运行控制循环。

### 再次测试

由于 代码已使用 rttest 进行检测，因此可以使用一些有用的命令行参数。

| 参数 | 描述 | 默认值 |
|:----|:----|:-------|
| -i  | 指定实时循环的迭代次数 | 1000 | 
| -u  | 指定更新周期，默认单位为微秒。可以通过后缀 s/ms/us/ns 分别指定 秒/毫秒/微秒/纳秒 | 1ms |
| -f  | 指定用于写入收集数据的文件名 | |

再次运行演示程序，并指定文件名以保存结果:
```s
pendulum_demo -f pendulum_demo_results
```

然后 rttest_plot 对生成的文件运行脚本:
```s
rttest_plot pendulum_demo_results
```
执行后将生成三个文件(对结果的绘制):
````s
pendulum_demo_results_plot_latency.svg
pendulum_demo_results_plot_majflts.svg
pendulum_demo_results_plot_minflts.svg
```