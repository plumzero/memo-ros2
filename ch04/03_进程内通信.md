
参考:
- [Setting up efficient intra-process communication](https://docs.ros.org/en/foxy/Tutorials/Demos/Intra-Process-Communication.html)

### 双节点流水线演示

此演示旨在表明，当使用 `std::unique_ptr` 发布和订阅时，进程内发布/订阅连接可以实现消息的零拷贝传输。

执行如下命令，创建一个 demo_two_node_pipeline_package 的功能包:
```s
cd src
ros2 pkg create --build-type ament_cmake demo_two_node_pipeline_package --dependencies rclcpp std_msgs
```

创建并编写[main函数文件](src/demo_two_node_pipeline_package/src/two_node_pipeline.cpp)。在这个文件中，有一个生产者节点和一个消费者节点，将它们添加到单线程执行器中，然后调用 spin。

调整 CMakeLists.txt 后，执行如下命令完成编译:
```s
colcon build --packages-select demo_two_node_pipeline_package
```

执行如下命令运行程序:
```s
source install/setup.bash
ros2 run demo_two_node_pipeline_package two_node_pipeline
```
这里的部分输出如下:
```s
Published message with value: 0, and address: 0x5631E8276250
 Received message with value: 0, and address: 0x5631E8276250
Published message with value: 1, and address: 0x5631E8276250
 Received message with value: 1, and address: 0x5631E8276250
Published message with value: 2, and address: 0x5631E8276250
 Received message with value: 2, and address: 0x5631E8276250
Published message with value: 3, and address: 0x5631E8276250
 Received message with value: 3, and address: 0x5631E8276250
Published message with value: 4, and address: 0x5631E8276250
 Received message with value: 4, and address: 0x5631E8276250
Published message with value: 5, and address: 0x5631E8276250
 Received message with value: 5, and address: 0x5631E8276250
Published message with value: 6, and address: 0x5631E8276250
 Received message with value: 6, and address: 0x5631E8276250
Published message with value: 7, and address: 0x5631E8276250
 Received message with value: 7, and address: 0x5631E8276250
...
```
可以看到，生产者会打印出地址和值，消费者也会打印出与之匹配的地址和值。这表明进程内通信确实有效，并且避免了不必要的复制。

> 上面的测试中，"Published message…"和"Received message …"行对之间值不同，但地址相同。这可能是由于程序在同样的地址上分配内存。

### 循环管道演示

创建并编写[main函数文件](src/demo_two_node_pipeline_package/src/cyclc_pipeline.cpp)。在文件的 IncrementerPipe 类中同时创建 pub 和 sub 句柄，分别用于发布 out 主题和订阅 in 主题。

创建两个节点 pipe1 和 pipe2，其中 pipe1 发布 topic2 主题，订阅 topic1 主题；pipe2 发布 topic1 主题，订阅 topic2 主题。

首先在 main 函数中创建一个值(大小为 42)，由 pipe1 (以 topic2 主题)发布出去，然后在 pipe1 和 pipe2 之间，完成对值的"乒乓"递增逻辑。

调整 CMakeLists.txt 后完成编译。

执行如下命令运行程序:
```s
source install/setup.bash
ros2 run demo_two_node_pipeline_package cyclc_pipeline
```
这里的部分输出如下:
```s
Published first message with value:  42, and address: 0x55C30DCA33E0
Received message with value:         42, and address: 0x55C30DCA33E0
  sleeping for 1 second...
  done.
Incrementing and sending with value: 43, and address: 0x55C30DCA33E0
Received message with value:         43, and address: 0x55C30DCA33E0
  sleeping for 1 second...
  done.
Incrementing and sending with value: 44, and address: 0x55C30DCA33E0
Received message with value:         44, and address: 0x55C30DCA33E0
  sleeping for 1 second...
  done.
...
```
可以看到每次迭代的数字从 42 开始不断增加，但指针地址没有改变，这说明确实避免了不必要的复制。
