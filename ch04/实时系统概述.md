
参考:
- [Introduction to Real-time Systems](https://design.ros2.org/articles/realtime_background.html)

本文简要概述了实时计算的要求以及实现实时性能的方法。

## 实时计算的定义

实时计算的定义需要先定义其他几个关键术语:
- 确定性: 如果一个系统对于已知的输入总是产生相同的输出，那么该系统就是确定性的。非确定性系统的输出则会随机波动。
- 截止日期: 截止日期是指完成某项任务必须限定的有限时间范围。
- 服务质量: 网络的整体性能。包括带宽、吞吐量、可用性、抖动、延迟和错误率等因素。

实时软件保证在正确的时间进行正确的计算。

`硬实时软件系统`具有一套严格的截止时间，错过截止时间即被视为系统故障。硬实时系统的例子包括: 飞机传感器和自动驾驶系统、航天器和行星探测车。

`软实时系统`力求按时完成任务，但即使错过截止时间也不会崩溃。然而，为了提高响应速度，它们可能会在这种情况下降低服务质量。软实时系统的例子包括: 用于娱乐的音频和视频传输软件(延迟虽然不理想，但并非灾难性的)。

`严格实时系统`会将截止时间后交付的信息/进行的计算视为无效。与软实时系统类似，它们不会在错过截止时间后发生故障，但如果错过截止时间，它们可能会降低服务质量。严格实时系统的例子包括: 金融预测系统、机器人装配线。

实时计算机系统通常与低延迟系统联系在一起。许多实时计算应用本身也是低延迟应用(例如，自动驾驶系统必须能够对环境的突发变化做出反应)。然而，实时系统的定义并非基于低延迟，而是基于确定性的调度: 必须保证系统在特定时间完成特定任务。因此，系统延迟的可测量性以及任务允许的最大延迟至关重要。

实时计算机系统既需要实时运行的操作系统，也需要能够确定性执行的用户代码。**在非实时操作系统上运行确定性用户代码，或在实时操作系统上运行非确定性代码，都无法实现实时性能。**

实时环境的一些示例:
- Linux RT_PREEMPT 内核补丁，修改 Linux 调度器使其完全可抢占。
- Xenomai 是一个符合 POSIX 标准的协同内核(或虚拟机管理程序)，它提供一个与 Linux 内核协同工作的实时内核。Linux 内核被视为实时内核调度器的空闲任务(优先级最低的任务)。
- RTAI，一种替代的协同内核解决方案。
- QNX Neutrino，一款符合 POSIX 标准的实时操作系统，适用于关键任务系统。

## 实时计算最佳实践

一般来说，操作系统可以保证它为开发者处理的任务(例如线程调度)是确定性的，但操作系统无法保证开发者的代码能够实时运行。因此，开发者需要了解现有系统的确定性保证是什么，以及为了在操作系统之上编写真正的实时代码，必须做些什么。

本节探讨了在实时操作系统之上进行开发的各种策略。这些模式主要针对在基于 Linux 的实时操作系统(例如 ROS RT_PREEMPT)上进行 C/C++ 开发的用例，但其基本概念也适用于其他平台。大多数模式都侧重于解决操作系统中的阻塞调用问题，因为任何涉及阻塞时间不确定的操作都是不确定的。

将实时代码分成三个部分是一种常见的模式: 进程开始时的非实时安全部分，用于在堆上预分配内存、启动线程等; 实时安全部分(通常用循环实现); 以及非实时安全的"清理"部分，用于根据需要释放内存等。"实时代码路径"指的是执行的中间部分。

### 内存管理

合理的内存管理对于实时性能至关重要。通常，程序员应该避免在实时代码路径中发生缺页错误。发生缺页错误时，CPU 会暂停所有计算，并将缺失的页面从磁盘加载到 RAM(或缓存、寄存器)中。从磁盘加载数据是一个缓慢且不可预测的操作。然而，缺页错误是必要的，否则计算机将耗尽内存。因此，避免缺页错误是解决之道。

动态内存分配会导致实时性能下降。对内存的调用 malloc/new 和 free/delete 可能导致页面错误。此外，堆内存分配和释放的方式会导致内存碎片化，从而降低读写性能，因为操作系统可能需要花费不确定的时间扫描空闲内存块。

#### 锁定内存，预分配堆栈

```c
if (mlockall(MCL_CURRENT|MCL_FUTURE) == -1) {
  perror("mlockall failed");
  exit(-2);
}
unsigned char dummy[MAX_SAFE_STACK];

memset(dummy, 0, MAX_SAFE_STACK);
```
[mlockall](https://linux.die.net/man/2/mlockall)是一个 Linux 系统调用，用于将进程的虚拟地址空间锁定到 RAM 中，防止进程将要访问的内存被分页到 swap 空间。

这段代码片段在线程生命周期开始时运行，可以确保线程运行时不会发生页面错误。 mlockall 会锁定线程的栈。memset 调用会将栈的每个内存块预加载到缓存中，这样在访问栈时就不会发生页面错误。

#### 分配动态内存池

```c
if (mlockall(MCL_CURRENT | MCL_FUTURE))
  perror("mlockall failed:");

/* Turn off malloc trimming.*/
mallopt(M_TRIM_THRESHOLD, -1);

/* Turn off mmap usage. */
mallopt(M_MMAP_MAX, 0);

page_size = sysconf(_SC_PAGESIZE);
buffer = malloc(SOMESIZE);

for (i=0; i < SOMESIZE; i+=page_size) {
  buffer[i] = 0;
}
free(buffer);
```
动态内存分配通常不具备实时安全性。然而，以上代码片段展示了如何使动态内存分配(基本)具备实时安全性。它将虚拟地址空间锁定为固定大小，禁止通过 `fs.returns()` 将已释放的内存返回给内核sbrk，并禁用 `fs.returns() mmap`。这有效地将堆中的内存池锁定到 RAM 中，从而防止因 `fs.returns()`malloc和`fs.returns()` 导致的页面错误 free。

优点:
- 可以使用 malloc/new、free/delete，甚至 STL 容器

缺点:
- 平台/实现方式取决于具体情况
- 必须准确预测进程的有限内存大小！
- 因此，使用STL容器是危险的(大小不受限制)。
- 实际上，这种方法仅适用于内存占用较小的进程。

#### 自定义实时安全内存分配器

大多数操作系统上的默认内存分配器并未针对实时安全性进行优化。然而，还有一种策略可以作为"避免动态内存分配"规则的例外。

TLSF(两级隔离适配)就是这样一种替代分配器。它也被称为 O(1) 分配器，因为TLSF 下 malloc`a`、free`b` 和 `c`align 操作的时间成本有一个固定的上限。它产生的碎片化程度很低。TLSF 的缺点是它不是线程安全的，并且其当前实现与架构相关: 它假定系统可以进行 4 字节对齐的访问。

优点:
- 能够在运行时或编译时内存边界未知的情况下，安全地为程序分配内存
- 优势因分配者的选择而异。

缺点:
- 由于自定义分配器的使用范围较小，因此其实现可能未经充分测试。
- 额外的依赖项，可能导致代码复杂度增加
- 缺点因分配者的选择而异。

#### 全局变量和(静态)数组

全局变量在进程启动时预先分配，因此它们的赋值和访问是实时安全的。然而，这种策略也存在使用全局变量的诸多缺点。

#### 对指针和虚函数表访问的缓存友好性

由于虚函数表访问开销，具有多层继承的类可能不是实时安全的。执行继承函数时，程序需要访问函数中使用的数据、类的虚函数表以及函数指令，这些信息都存储在内存的不同位置，并且可能同时存储在缓存中，也可能没有同时存储。

一般来说，缓存局部性差的 C++ 模式(例如桥接模式)不太适合实时环境。不透明指针惯用法(PIMPL)就是其中之一，它有利于 ABI 兼容性并加快编译速度。然而，在对象内存地址和其私有数据指针之间频繁跳转会导致缓存"溢出"，因为对于 PIMPL 化对象中的几乎每个函数，它都会加载一块内存，然后再加载另一块不相关的内存。STL 的 vector、list 等采用的就是 PIMPL 实现方式，共享指针 `shared_ptr<T>(new T)` 构造方式也是将控制块与内存对象本身分开的。

对局部变量(尤其是大的对象)的压栈和出栈的执行，也会对资源产生消耗。如果将一些特定变量声明为全局或预先在动态内存上创建，而在实际执行上对指向这个变量对象的指针进行压栈和出栈操作，或许也可以产生一定的优化。

### 处理异常

处理异常可能会造成很大的性能损失。遇到异常往往会将大量内存压入堆栈，而堆栈在实时编程中通常是一种有限的资源。但是，如果正确使用异常，它们就不应该成为实时程序员的担忧(因为它们指示程序中存在未定义行为的位置，并且是调试不可或缺的一部分)。

### 设备 I/O

与物理设备交互(例如磁盘 I/O、屏幕打印等)可能会在实时代码路径中引入不可接受的延迟，因为进程通常被迫等待缓慢的物理现象。此外，许多 I/O 调用会导致 fopen 页面错误。

将磁盘读取/写入操作放在程序的开头或结尾，放在实时代码路径之外。

启动未实时调度的线程，将输出打印到屏幕。

### 多线程编程与同步

实时计算的需求改变了传统的多线程编程范式。程序执行不能异步阻塞，线程必须确定性地调度。实时操作系统能够满足这种调度要求，但开发者仍然可能遇到一些陷阱。

#### 线程创建原则

在程序启动时创建线程。这样可以将线程分配带来的不确定性开销限制在进程中的特定时间点。

使用 FIFO、Round Robin 或 Deadline 调度器创建高优先级(但不是 99)线程(参见[POSIX调度API](https://man7.org/linux/man-pages/man7/sched.7.html))。

#### 避免优先级反转

在采用抢占式任务调度器的系统中，可能会发生优先级反转，并导致死锁。这种情况发生在: 一个低优先级任务获取了锁，然后被一个中优先级任务抢占，接着一个高优先级任务获取了原本由低优先级任务持有的锁。

这三个任务陷入了一个三角形: 高优先级任务被低优先级任务阻塞，低优先级任务又被中优先级任务阻塞，因为它被优先级更高的任务抢占了; 而中优先级任务也被优先级更高的任务阻塞了。

以下是一些解决优先级反转问题的方案:
- 不要使用阻塞式同步原语
- 禁用持有锁的任务的抢占(可能导致抖动)
- 提高持有锁的任务的优先级
- 使用优先级继承: 持有锁的任务会继承尝试获取该锁的任务的优先级
- 使用无锁数据结构和[算法](http://www.1024cores.net/home/lock-free-algorithms)

#### 时间点瞄准

一种实时同步技术是让线程计算其下一个"时间点"(即下一个执行周期的开始时间)。例如，如果一个线程需要每 10 毫秒更新一次，并且它必须完成一个耗时 3-6 毫秒的操作，那么该线程应该在操作开始前获取时间，执行操作，然后根据操作后的时间等待剩余的 7-4 毫秒。

对于开发者而言，最重要的考虑因素是在等待过程中使用高精度计时器，例如 nanosleep 在 Linux 平台上。否则，系统会出现漂移。

#### 自旋锁

自旋锁容易导致时钟漂移。开发者应避免自行实现自旋锁。RT Preempt 补丁将内核中的大部分自旋锁替换为互斥锁，但这并不能保证在所有平台上都有效。

#### 避免 fork

[fork](https://linux.die.net/man/3/memset)并非实时安全，因为它采用了写时复制([copy-on-write](https://en.wikipedia.org/wiki/Copy-on-write))机制。这意味着当一个派生进程修改内存页时，它会获得该内存页的副本。这会导致缺页错误！

实时编程中应避免页面错误，因此应避免使用 Linux fork 以及调用该函数的程序。

## 测试与性能基准测试

### 循环测试

[cyclictest](https://manpages.ubuntu.com/manpages/trusty/man8/cyclictest.8.html)是一个简单的 Linux 命令行工具，用于测量实时环境的抖动。它接受线程数、线程优先级和调度器类型作为输入。它会启动一些 n 线程，这些线程会定期休眠(也可以从命令行指定休眠周期)。

对于每个线程，cyclictest 测量线程应该唤醒到实际唤醒之间的时间。这种延迟的变化就是系统中的调度抖动。如果系统中运行着具有非确定性阻塞行为的进程，平均延迟将增长到一个很大的数值(毫秒级)，因为调度器无法满足程序中分析的周期性休眠线程的截止时间。

### 用于测试的代码插桩

更精确地测量程序调度抖动的方法是，对现有代码的周期性实时更新循环进行检测，以记录调度抖动。

这里可以找到一个用于实时代码检测的最小库的提议头文件: [rttest.h](https://github.com/ros2/realtime_support/blob/master/rttest/include/rttest/rttest.h)。

### 页面错误

Linux 系统调用[getrusage](https://linux.die.net/man/2/getrusage)会返回与实时性能相关的许多资源使用事件的统计信息，例如 minor 和 major pagefaults、swaps 以及 block I/O。它可以检索整个进程或单个线程的这些统计信息。因此，很容易对代码进行插桩以检查这些事件。特别是，getrusage 应该在代码的实时部分之前和之后立即调用`get_requests()`，并比较这些结果，因为`getrusageget_requests()`收集的是线程/进程整个运行期间的统计信息。

收集这些统计数据可以指示哪些事件可能导致前面描述的方法所测量的延迟/调度抖动。

